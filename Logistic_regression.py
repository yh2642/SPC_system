from numpy import *import randomdef loadDataSet(df):	numFeat = df.values.shape[1] - 1	print "feature is ", numFeat	dataMat = []; labelMat = []	for line in df.values:		lineArr = []		for i in range(numFeat):			lineArr.append(float(line[i]))		dataMat.append(lineArr)		labelMat.append(float(line[-1]))	return dataMat, labelMat	def sigmoid(inX):	return 1.0 / (1 + exp(-inX))	def gradAscent(dataMatIn, classLabels):	dataMatrix = mat(dataMatIn)	labelMat = mat(classLabels).transpose()	m, n = shape(dataMatrix)	alpha = 0.01	maxCycles = 10000	weights = ones((n, 1))	for k in range(maxCycles):		h = sigmoid(dataMatrix * weights)		error = (labelMat - h)		weights = weights + alpha * dataMatrix.transpose() * error	return weightsdef stocGradAscent1(dataMatrix, classLabels, numIter = 150):	m, n = shape(dataMatrix)	weights = ones(n)	for j in range(numIter):		dataIndex = range(m)		for i in range(m):			alpha = (1 / (1.0 + j + i)) +0.01			randIndex = int(random.uniform(0, len(dataIndex)))			h = sigmoid(sum(dataMatrix[randIndex] * weights))			error = classLabels[randIndex] - h			weights = weights + alpha * error * dataMatrix[randIndex]			del(dataIndex[randIndex])	return weights	def classifyVector(inX, weights):	prob = sigmoid(sum(inX * weights))	print prob	if prob > 0.5: return 1.0	else: return 0.0	def mtTest(tspc1, mspc1):	col= [#'xCL',				#'RsCL',				'err1',				#'zone4_dist',				#'zone3_dist',				#'zone2_dist',				#'zone1_dist',				#'err2',				#'err3',				#'err4',				#'err5',				#'err6',				#'err8',				'Rs_err1',				#'Rsd4_dist',				#'Rsd3_dist',				#'last_record',				#'Rsd2_dist',				#'Rsd1_dist',				#'Rsd0_dist',				#'mean_dev19_1',				'mean_dev9_1',				#'mean_dev5_1',				#'mean_dev17_3',				#'mean_dev7_3',				#'mean_dev15_5',				#'mean_dev10_5',				'step_dev17_3',				#'step_dev10_3',				#'step_dev15_5',				#'step_dev10_5',				#'step_before5',				#'step_before3',				#'max_before5',				#'max_before20',				'max_dev20_5',				#'max_dev20_20',				#'min_before5',				#'min_before20',				'min_dev20_5',				#'min_dev20_20',				'reason_mean',				#'reason_step',				 'label'] 		tspc1['label'] = 1.0	mspc1['label'] = 0		       	data_t = tspc1.reindex(columns = col)	data_m = mspc1.reindex(columns = col)	for i in col[:-1]:		data_t[i] = data_t[i] / (data_t[i].mean() /2.0 + data_m[i].mean()/2.0)		data_m[i] = data_m[i] / (data_t[i].mean()/2.0 + data_m[i].mean()/2.0)		xArr_t, yArr_t = loadDataSet(data_t)	xArr_m, yArr_m = loadDataSet(data_m)	trainingSet = []; trainingLabels = []; testingSet = []; testingLabels = []	'''	trainingSet.extend(xArr_t[-94:])	trainingSet.extend(xArr_m[-94:])	trainingLabels.extend(yArr_t[-94:])	trainingLabels.extend(yArr_m[-94:])		testingSet.extend(xArr_t[:20])	testingSet.extend(xArr_m[:20])	testingLabels.extend(yArr_t[:20])	testingLabels.extend(yArr_m[:20])	testingSet = trainingSet	testingLabels = trainingLabels	'''		n = 94		indx_pool = range(len(xArr_t))	while n > 0:		rand_indx = random.choice(indx_pool)		trainingSet.append(xArr_t[rand_indx])		trainingLabels.append(yArr_t[rand_indx])		indx_pool.remove(rand_indx)		n -= 1	#for indx in indx_pool:		#testingSet.append(xArr_t[indx])		#testingLabels.append(yArr_t[indx])	n = 20	for indx in indx_pool:		testingSet.append(xArr_t[indx])		testingLabels.append(yArr_t[indx])		n = 94	indx_pool = range(len(xArr_m))	while n > 0:				rand_indx = random.choice(indx_pool)		trainingSet.append(xArr_m[rand_indx])		trainingLabels.append(yArr_m[rand_indx])		indx_pool.remove(rand_indx)		n -= 1		for indx in indx_pool:		testingSet.append(xArr_m[indx])		testingLabels.append(yArr_m[indx])		print "the length of training set is ", len(trainingSet)	print "the length of testing set is ", len(testingSet)		feature_mean = array(trainingSet).mean(axis = 0)	trainWeights = stocGradAscent1(array(trainingSet), array(trainingLabels), 500)	#trainWeights = gradAscent(array(trainingSet), array(trainingLabels))	print trainWeights############# start testing	errorCount = 0; numTestVec = 0.0	for indx in range(len(testingSet)):		if classifyVector(array(testingSet[indx]), trainWeights) != 	testingLabels[indx]:			errorCount += 1	errorRate = float(errorCount) / len(testingLabels)	print "the error rate of this test is: %f" % errorRate	return errorRate	def multiTest(tspc1, mspc1):	numTests = 10; errorSum = 0.0	for k in range(numTests):		errorSum += mtTest(tspc1, mspc1)	print "after %d iterations the average error rate is: %f" % (numTests, errorSum / float(numTests))