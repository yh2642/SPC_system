import numpy as npE2 = 2.660D4 = 3.267def xCL_boundary(xCL, RsCL):	xUCL = xCL + E2 * RsCL	xUCL1 = xCL + (2.0 / 3) * E2 * RsCL	xUCL2 = xCL + (1.0 / 3) * E2 * RsCL	xCL = xCL	xLCL2 = xCL - (1.0 / 3) * E2 * RsCL	xLCL1 = xCL - (2.0 / 3) * E2 * RsCL	xLCL = xCL - E2 * RsCL	return xUCL, xUCL1, xUCL2, xCL, xLCL2, xLCL1, xLCLdef get_zone_x(x, xCL, RsCL):	xUCL, xUCL1, xUCL2, xCL, xLCL2, xLCL1, xLCL = xCL_boundary(xCL, RsCL)	if x > xUCL:		return 4	elif x <= xUCL and x > xUCL1:		return 3	elif x <= xUCL1 and x > xUCL2:		return 2	elif x <= xUCL2 and x > xCL:		return 1	elif x <= xCL and x > xLCL2:		return -1	elif x <= xLCL2 and x > xLCL1:		return -2	elif x <= xLCL1 and x > xLCL:		return -3	elif x <= xLCL:		return -4def x_zone_ls(data_subset, xCL, RsCL):	'''	Receive all zone_id for each list, better for spc analyze	'''	zone_ls = []	for ele in data_subset:		zone_ls.append(get_zone_x(ele, xCL, RsCL))	return zone_lsdef verify_error2(zone_ls):	'''	Consecutive 6-points on one side of xCL	'''		for indx in range(1, len(zone_ls)):			if zone_ls[indx] * zone_ls[indx - 1] < 0:			return 0	return 1	def verify_error3(Rs_ls):	'''	Consecutive n-points increasing or decreasing	'''		for indx in range(1, len(Rs_ls)):			if Rs_ls[indx] * Rs_ls[indx - 1] <= 0:			return 0	return 1def verify_error4(Rs_ls):	'''	Consecutive n-points keep switching	'''		for indx in range(1, len(Rs_ls)):			if Rs_ls[indx] * Rs_ls[indx - 1] >= 0:			return 0	return 1def verify_error5(zone_ls):	'''	2 in 3 point locate in A of D zone	'''		pos4 = zone_ls.count(4)	pos3 = zone_ls.count(3)	neg4 = zone_ls.count(-4)	neg3 = zone_ls.count(-3)	if pos4 + pos3 >= 2 or neg4 + neg3 >= 2:		return 1	else:		return 0def verify_error6(zone_ls):	'''	4 in 5 point locate in A B and D zone	'''		pos4 = zone_ls.count(4)	pos3 = zone_ls.count(3)	pos2 = zone_ls.count(2)	neg4 = zone_ls.count(-4)	neg3 = zone_ls.count(-3)	neg2 = zone_ls.count(-2)	if pos4 + pos3 + pos2 >= 4 or neg4 + neg3 + neg2 >= 4:		return 1	else:		return 0		def verify_error8(zone_ls):	'''	4 in 5 point locate in A B and D zone	'''		pos4 = zone_ls.count(4)	pos3 = zone_ls.count(3)	pos2 = zone_ls.count(2)	pos1 = zone_ls.count(1)	neg4 = zone_ls.count(-4)	neg3 = zone_ls.count(-3)	neg2 = zone_ls.count(-2)	neg1 = zone_ls.count(-1)	if pos1 + neg1 == 0:		return 1	else:		return 0def count_error1(zone_ls):	pos_4 = zone_ls.count(4)	neg_4 = zone_ls.count(-4)	return pos_4 + neg_4	def summary_distribution(zone_ls):	abs_zone = list(np.abs(zone_ls))	zone_dist = []	for indx in range(4, 0, -1):		zone_dist.append(abs_zone.count(indx))	return np.array(zone_dist) / float(np.sum(zone_dist))				#########################################################################################					def RsCL_boundary(RsCL):	RsUCL = D4 * RsCL	RsUCL1 = (RsUCL - RsCL) * (2.0 / 3) + RsCL	RsUCL2 = (RsUCL - RsCL) * (1.0 / 3) + RsCL	RsCL = RsCL		return RsUCL, RsUCL1, RsUCL2, RsCL	def get_zone_Rs(x, RsCL):	RsUCL, RsUCL1, RsUCL2, RsCL = RsCL_boundary(RsCL)	if x > RsUCL:		return 4	elif x <= RsUCL and x > RsUCL1:		return 3	elif x <= RsUCL1 and x > RsUCL2:		return 2	elif x <= RsUCL2 and x > RsCL:		return 1	elif x <= RsCL and x >= 0:		return 0		def Rs_zone_ls(data_subset, RsCL):	zone_ls = []	for ele in data_subset:		zone_ls.append(get_zone_Rs(ele, RsCL))	return zone_ls	def Rs_error1(zone_ls):	return zone_ls.count(4)	def Rs_distribution(zone_ls):	zone_dist = []	for indx in range(4, -1, -1):		zone_dist.append(zone_ls.count(indx))	return np.array(zone_dist) / float(np.sum(zone_dist))