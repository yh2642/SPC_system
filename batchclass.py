# -*- coding: utf-8 -*-import pandas as pdimport numpy as npimport osimport matplotlib.pyplot as pltimport sql_functions as sqlimport matplotlib.mlab as mlabfrom scipy import statsfrom datetime import datetimefrom flask import flashE2 = 2.660D4 = 3.267STANDARD_TU = 3.6STANDARD_TL = 3.0class Batch:	def __init__(self, line, modelID = None, modelinfo = None):		self.date = line[0]		self.batchID = line[1]				self.standard_Tu =  STANDARD_TU		self.standard_Tl = STANDARD_TL				if line[2] == '?':			self.outpressure = 'NULL'		else:			self.outpressure = line[2]				try:			if len(line[3]) >= 9:				self.modelID = line[3]				self.modeltimes = line[4]				self.records = line[5:]			else:				self.modelID = 'unknown'				self.modeltimes = 'unknown'				self.records = line[3:]		except IndexError:			self.modelID = 'unknown'			self.modeltimes = 'unknown'			self.records = []								# the process m or t in records		if 't' in self.records or 'm' in self.records:			self.except_point = 1		else:			self.except_point = 0				# string save in database for future use		strline = [str(ele) for ele in line]		self.original_text = ' '.join(strline)		### Basic Infomation			def __str__(self):		ans = "the info of this batch is: \n"		ans += "the batchmodel: " + self.modelID + "---"+str(self.modeltimes)		#ans += "other attributes" + self.modeltimes + self.outpressure + self.date + self.except_point + self.modelID		# ans += "the mean is %d, the std is %d", (self.get_mean(), self.get_std())		# ans += "max %d, min %d, range %d", self.get_range()		return ans	def get_records(self):		positive_records = []		except_point = 0		for indx in range(len(self.records)):			ele = self.records[indx]			if ele in ['m', 'l'] or 't' in ele:				if not (self.records[indx - 1] in ['m', 'l'] or 't' in self.records[indx - 1]):					positive_records.pop()							elif ele == 'switch' or '/' in ele:				pass			else: 				#try:				positive_records.append(float(ele))				#except ValueError:				#	flash(u'%s无法正确显示请删除！' % ele)		return positive_records			def get_raw_records(self):		"""		for generate spc table		"""		raw_records = []		except_point = 0		for ele in self.records:			if ele in ['m', 'l'] or 't' in ele or ele == 'switch' or '/' in ele:						pass			else: 				print ele				#try:				raw_records.append(float(ele))				#except ValueError:				#	flash(u'%s无法正确显示请删除！' % ele)		return raw_records				def get_positive_records(self):		"""		this methods to transfer all records into float type except 'm l t switch'		it is used in the method get_check_records only		"""		raw_records = []		except_point = 0		for ele in self.records:			if ele in ['m', 'l'] or 't' in ele or ele == 'switch' or '/' in ele:						raw_records.append(ele)			else: 				#try:				raw_records.append(float(ele))				#except ValueError:				#	flash(u'%s无法正确显示请删除！' % ele)		return raw_records						def get_records_length(self):		return len(self.get_raw_records())					def get_check_records(self):		check_list = [u'\u2713'] * (self.get_records_length())		data_index = -1		positive_records = self.get_positive_records()		for indx in range(len(positive_records)):			if type(positive_records[indx]) is float:				data_index += 1			#elif 'j' in positive_records[indx]:			else:				if type(positive_records[indx - 1]) is float:					check_list[data_index] = ''					if 't' in positive_records[indx] and positive_records[indx] != 'switch':						check_list[data_index] += u'调' + ' '					elif 'm' in positive_records[indx]:						check_list[data_index] += u'磨' + ' '					elif 'l' in positive_records[indx]:						check_list[data_index] += u'漏' + ' '					elif positive_records[indx] == 'switch':						check_list[data_index] += u'换台机器' + ' '					elif '/' in positive_records[indx]:						check_list[data_index] += '(' + positive_records[indx][1:] + ')'				else:					if 't' in positive_records[indx] and positive_records[indx] != 'switch':						check_list[data_index] += u'调' + ' '					elif 'm' in positive_records[indx]:						check_list[data_index] += u'磨' + ' '					elif 'l' in positive_records[indx]:						check_list[data_index] += u'漏' + ' '					elif '/' in positive_records[indx]:						check_list[data_index] += '(' + positive_records[indx][1:] + ')'		return check_list			def update_outpressure(self):		pressure_list = ["''"] * (self.get_records_length()//5 + 1)		pressure_list[0] = self.outpressure		data_index = -1		positive_records = self.get_positive_records()		for indx in range(len(positive_records)):			if type(positive_records[indx]) is float:				data_index += 1			#elif 'j' in positive_records[indx]:			elif 't' in positive_records[indx] and positive_records[indx] != 'switch':				pressure_list[data_index // 5] = float(positive_records[indx][1:])		return pressure_list			def add_record(self, new_record):		if new_record in ['m', 'l'] or 't' in new_record or new_record == 'switch' or '/' in new_record:			self.records.append(new_record)		else:			try:				test_valid = float(new_record)				self.records.append(new_record)				flash(u'成功添加记录！')			except ValueError:				flash(u'数据输入错误，请检查！')				def pop_record(self):		try:			self.records.pop()			flash(u'成功删除记录！')		except:			flash(u'记录删除失败！')					def get_mean(self):		return pd.Series(self.get_records()).mean()	def get_std(self):		return pd.Series(self.get_records()).std()	def get_max(self):		return pd.Series(self.get_records()).max()	def get_min(self):					return pd.Series(self.get_records()).min()	def get_range(self):		return self.get_max() - self.get_min()			def get_span(self):		return str(self.get_min()) + '~' + str(self.get_max())			def get_batchtype(self):   #B C or D?		if 'B' in self.batchID:			return 'b'		elif 'C' in self.batchID:			return 'c'		elif 'D' in self.batchID:			return 'd'				def update_modelinfo(self, modelID, modeltimes):		self.modelID = modelID		self.modeltimes = modeltimes				### SPC		def step_pool(self):		test_sample = self.get_records()		step_pool = []		for indx in range(1, len(test_sample)):			single_step = abs(test_sample[indx] - test_sample[indx - 1])			step_pool.append(single_step)		return step_pool			def get_step_mean(self):		return np.mean(self.step_pool())	def set_xCL(self):		if len(self.get_records()) < 20:			if self.modeltimes == 1:				data_month = sql.output_stat_data(self.date, 7, self.get_batchtype())				xCL = float('%.4f'%data_month.means.mean())			elif self.modelID != 'unknown':				data_model = sql.output_model(self.modelID, self.get_batchtype())				xCL = data_model.means.mean()			else:				data_month = sql.output_stat_data(self.date, 7, self.get_batchtype())				xCL = float('%.4f'%data_month.means.mean())		else:			xCL = self.get_mean()		return xCL		def set_RsCL(self):		if len(self.get_records()) < 20:			if self.modeltimes == 1:				data_month = sql.output_stat_data(self.date, 30, self.get_batchtype())				RsCL = float('%.4f'%data_month.step_mean.mean())			elif self.modelID != 'unknown':				data_model = sql.output_model(self.modelID, self.get_batchtype())				RsCL = data_model.step_mean.mean()			else:				data_month = sql.output_stat_data(self.date, 7, self.get_batchtype())				RsCL = float('%.4f'%data_month.step_mean.mean())		else:			RsCL = self.get_step_mean()		return RsCL				def set_xUCL(self):		return self.set_xCL() + E2 * self.set_RsCL()			def set_xLCL(self):		return self.set_xCL() - E2 * self.set_RsCL()			def set_RsUCL(self):		return D4 * self.set_RsCL()			def process_plot(self):		x = np.arange(1, len(self.get_records()) + 1)		x2 = np.arange(2, len(self.get_records()) + 1)		y2 = self.step_pool()		y = self.get_records()		#pt1 = pd.Series(self.get_records())				### Local Variable		xCL = self.set_xCL()		RsCL = self.set_RsCL()		xUCL =  self.set_xUCL()		xLCL = self.set_xLCL()		RsUCL = self.set_RsUCL()				fig, axes = plt.subplots(nrows = 2, ncols = 1, sharex = True, )				axes[0].plot(x, y, color='k', linestyle='-.', marker='o', alpha = 0.5)		axes[1].plot(x2, y2, color='green', linestyle='-.', marker='o', alpha = 0.5)		#axes[0].set_ylim([3.0, 4.0])		if self.get_records_length() <= 60:			axes[0].set_xlim([0, 60])				#axes[1].set_ylim([-.05, 0.4])				axes[0].set_title(u'%s批次爆破片生产过程图' % self.batchID, fontproperties='SimHei')			axes[0].set_ylabel(u'爆破压力（Mpa）', fontproperties='SimHei')		axes[1].set_xlabel(u'抽检次数', fontproperties='SimHei')		axes[1].set_ylabel(u'移动极差（Mpa）', fontproperties='SimHei')				axes[0].axhline(self.set_xCL(), color='red', lw=2, alpha=0.5, label = 'CL = %.2f'%self.set_xCL())		axes[0].annotate(u'均值', xy = (60, xCL), xytext = (61, xCL - .03), color = 'black', arrowprops = None, fontproperties='SimHei')		axes[0].annotate(u'上限', xy = (60, xUCL), xytext = (61, xUCL - .03), color = 'black', arrowprops = None, fontproperties='SimHei')		axes[0].annotate(u'下限', xy = (60, xLCL), xytext = (61, xLCL - .03), color = 'black', arrowprops = None, fontproperties='SimHei')		axes[1].annotate(u'均值', xy = (60, RsCL), xytext = (61, RsCL - .015), color = 'black', arrowprops = None, fontproperties='SimHei')		axes[1].annotate(u'上限', xy = (60, RsUCL), xytext = (61, RsUCL - .015), color = 'black', arrowprops = None, fontproperties='SimHei')						axes[0].axhline(xUCL, color='red', lw=2, linestyle='dashed', alpha=0.5, label = "UCL")		axes[0].axhline(xLCL, color='red', lw=2, linestyle='dashed', alpha=0.5, label = "LCL")		axes[1].axhline(RsCL, color='red', lw=2, alpha=0.5)		axes[1].axhline(RsUCL, color='red', lw=2, linestyle='dashed', alpha=0.5)		for n in [-2, -1, 1, 2]:			axes[0].axhline(xCL + n*((xUCL - xLCL)/6), color='red', lw=1, linestyle='dashed', alpha=0.5)			axes[1].axhline(RsCL + abs(n)*((RsUCL - RsCL)/3), color='red', lw=1, linestyle='dashed', alpha=0.25)						crisis_data = self.crisis_data()		if len(self.crisis_data()) > 0:			for ele in self.crisis_data():				axes[0].plot(ele[0], float(ele[1]), marker = 'o', color = 'r', alpha = 0.8)				axes[0].annotate(ele[2].upper(), xy = (ele[0], float(ele[1])), xytext = (ele[0] + .5, float(ele[1]) + 0.015), size = 8, alpha = 0.7, color = 'r', arrowprops = None)				filename = 'static/images/batch_records/' + self.batchID + str(datetime.now().minute) + str(datetime.now().second) + '.png'				plt.subplots_adjust(hspace = .1)				if os.path.exists(filename):			os.remove(filename)		plt.savefig(filename, dpi = 240)		plt.close('all')		return filename								###	SQC		def count_except(self, exc = 'l'):		return self.records.count(exc)		def procedure_index(self):		cp = (self.standard_Tu - self.standard_Tl) / (6 * self.get_std())		return cp			def procedure_index_dev(self):		cpk = min([abs(self.standard_Tu - self.get_mean()), abs(self.standard_Tl - self.get_mean())]) / (3 * self.get_std())		return cpk		def dev_index(self):		k = abs(.5 * (self.standard_Tu + self.standard_Tl) - self.get_mean())		k /= .5 * (self.standard_Tu - self.standard_Tl)		return k			def upper_fail_rate(self):		pu = 1 - stats.norm.cdf(3 * self.procedure_index() * (1 - self.dev_index()))		return pu			def lower_fail_rate(self):		pl = 1 - stats.norm.cdf(3 * self.procedure_index() * (1 + self.dev_index()))		return pl		def total_fail_rate(self):		return self.upper_fail_rate() + self.lower_fail_rate()		def crisis_data(self):		crisis_data = []		n_f = 0		for indx in range(len(self.records)):			if self.records[indx] in ['m','l'] or 't' in self.records[indx]:								if self.records[indx - 1] in ['m','l'] or 't' in self.records[indx - 1]:					crisis_data[-1][2] += '+' + self.records[indx]				elif '/' in self.records[indx - 1]:					leng = len(crisis_data)					crisis_data.append([n_f - leng, self.records[indx-1], self.records[indx]])			else:				n_f += 1		return crisis_data			def stat_info(self):		stat_table = []		stat_table.append([self.date, self.outpressure, float('%.4f'%self.get_mean()), float('%.4f'%self.get_std()), self.get_span(), float('%.4f'%self.get_step_mean()), 							float('%.3f'%self.procedure_index_dev()), '%.2f%%' % (100 * self.upper_fail_rate()), '%.2f%%' % (100 * self.lower_fail_rate()), 							'%.2f%%' % (100 * self.total_fail_rate())])		# data in a month		data_month = sql.output_stat_data(self.date, 30, self.get_batchtype())		stat_table.append([u'近30天平均记录', '---', float('%.4f'%data_month.means.mean()), float('%.4f'%data_month.stds.mean()), '---', float('%.4f'%data_month.step_mean.mean()), 							float('%.3f'%data_month.procedure_index.mean()), '%.2f%%' % (100 * data_month.upper_fail_rate.mean()), '%.2f%%' % (100 * data_month.lower_fail_rate.mean()),							'%.2f%%' % (100 * data_month.total_fail_rate.mean())])		# add data within a year		data_year = sql.output_stat_data(self.date, 365, self.get_batchtype())		stat_table.append([u'近一年平均记录', '---', float('%.4f'%data_year.means.mean()), float('%.4f'%data_year.stds.mean()), '---', float('%.4f'%data_year.step_mean.mean()), 							float('%.3f'%data_year.procedure_index.mean()), '%.2f%%' % (100 * data_year.upper_fail_rate.mean()), '%.2f%%' % (100 * data_year.lower_fail_rate.mean()),							'%.2f%%' % (100 * data_year.total_fail_rate.mean())])		return stat_table					def history_test_hist(self):		ttdf = sql.output_stat_data(self.date, 1500, self.get_batchtype())		all_test = list(ttdf.text)		all_string = ''		for ele in all_test:			all_string += ele			all_string += ' '		all_list = all_string.strip().split()		result_list = [float(ele) + 0.05 * np.random.randn() for ele in all_list if '3.' in ele and '/' not in ele]		mu = pd.Series(result_list).mean() # mean of distribution		sigma = pd.Series(result_list).std() # standard deviation of distribution		x = mu + sigma * np.random.randn(len(result_list))		num_bins = 30		# the histogram of the data		n, bins, patches = plt.hist(result_list, num_bins, normed=1, facecolor='green', alpha=0.5)		# add a 'best fit' line		y = mlab.normpdf(bins, mu, sigma)		plt.plot(bins, y, 'r--')		# plt.hist(x, num_bins, normed=1, facecolor='green', alpha=0.1)		plt.xlabel('Smarts')		plt.ylabel('Probability')		plt.title(r'Histogram of IQ: $\mu=%f$, $\sigma=%f$' % (mu, sigma))		# Tweak spacing to prevent clipping of ylabel		plt.subplots_adjust(left=0.15)		filename = 'static/images/history_hist/' + self.batchID + '__sample.png'		if os.path.exists(filename):			os.remove(filename)		plt.savefig(filename)		plt.close('all')		return filename		def history_scatter_subplot(self):		fig = plt.figure()		ax1= fig.add_subplot(2, 2, 1)		ax2= fig.add_subplot(2, 2, 2)		ax3 = fig.add_subplot(2, 2, 3)		ax4 = fig.add_subplot(2, 2, 4)		data = sql.output_stat_data(self.date, 365, self.get_batchtype())		all_pressure = data.outpressure.replace('NULL', np.nan)		outpressure = [float(ele) for ele in list(all_pressure)]		all_means = list(data.means)		all_std = list(data.stds)		all_range = list(data.ranges)		ax1.scatter(all_means, all_std, color='DarkGreen', alpha = 0.3)		ax2.scatter(all_means, all_range, color='DarkBlue', alpha = 0.3)		ax3.scatter(outpressure, all_means, color = 'DarkRed', alpha = 0.3)		ax4.scatter(outpressure, all_std, color = 'Black', alpha = 0.3)		filename = 'static/images/history_hist/' + self.batchID + str(datetime.now().minute) + str(datetime.now().second) + '__subplot.png'		if os.path.exists(filename):			os.remove(filename)		plt.savefig(filename)		plt.close('all')		return filename			def history_hist_subplot(self):		fig = plt.figure()		ax1= fig.add_subplot(2, 2, 1)		ax2= fig.add_subplot(2, 2, 2)		ax3 = fig.add_subplot(2, 2, 3)		# ax4 = fig.add_subplot(2, 2, 4)		data = sql.output_stat_data(self.date, 365, self.get_batchtype())		all_means = list(data.means)		all_std = list(data.stds)		all_range = list(data.ranges)		ax1.hist(all_means, color='DarkGreen', alpha = 0.3)		ax2.hist(all_std, color='DarkBlue', alpha = 0.3)		ax3.hist(all_range, color = 'DarkRed', alpha = 0.3)		filename = 'static/images/history_hist/' + self.batchID + '__histsubplot.png'		if os.path.exists(filename):			os.remove(filename)		plt.savefig(filename)		plt.close('all')		return filename						